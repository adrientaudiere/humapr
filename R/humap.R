# \code{humap()} takes relevant specifications from user and uses those to invoke \code{ggplot()}.
# Output: \code{ggplot2} object that the user may modify with, e.g., \code{theme}.

#' Create a humap plot
#'
#' \code{humap} creates a ggplot object, using its own set of "geoms", i.e.,
#' human body oulines on which your data are projected in a heatmap-like
#' fashion. \code{humapr} is an extension of ggplot2, and objects created with
#' the \code{humap} function can be modified with standard ggplot2
#' setting--e.g., calls to \code{theme()}.
#'
#' If you don't supply a `side` argument humapr will assume default to mirroring
#' mode. If `side` argument is supplied, it will default to left/right
#' discrimate mode and show both body halves
#'
#' \code{humapr} uses XML files generated by \code{grImport::PostScriptTrace},
#' and comes with three levels of details (determined by the \code{setflat}
#' argument).
#'
#' If proj = "both" you cannot map right/left-discrimate data.
#'
#' @param data tidy data frame (more under details)
#' @param loc.var column in data frame containing localisation codes for
#'   observations. Character string.
#' @param lr.var variable indication left and right side of observations. Values
#'   must be "left" or "right".
#' @param region body region. Options: body (default), head, neck, arm,
#' @param gender n(eutral) (default), f(emale), m(male)
#' @param type topo(graphical), derma(tomes)
#' @param proj character string defining the projected front, back, both
#' @param half character string defining how to deal with body halves. "both"
#'   discriminates the left half from the right; "mirror" merges observations
#'   in, e.g., right and left side of the chest; "left"/"right" yields only the
#'   indicated half and ignores observations on the other half.
#' @param coding which coding scheme is used, currently supports simple and AIS
#' @param annotate none (defautlt), all, absolute, relative
#' @param outline_colour hexadecimal string indicating the colour of the outline.
#' @param anno_gp grid::gpar object. Default is fontsize = 9 and col = "black".
#' @param combine a \italic{list} of vectors naming the regions to be combined and
#'   mapped as one. E.g., list(arm = c("shoulder", arm", "elbow", "wrist"))
#'
#' @return A ggplot object with layout settings suitable for the kinds of geoms
#'   used in \code{humap}.
#' @export
#'
#' @examples
humap <- function(data, loc.var, lr.var = NULL, region = "body",
                  gender = "male", type = "topo", proj = "front",
                  half = "mirror", coding = "simple", annotate = TRUE,
                  outline_colour = "#222222", anno_gp = NULL,
                  combine = NULL) {

    # Safety moves. If invalid argument supplied, default chosen and user prompted.
    vargs <- list( # vargs = valid argument values
        c("region", "body"),
        c("proj", "front", "back", "both"),
        c("annotate", TRUE, FALSE)
    )
    for (i in seq(length(vargs))) {
        if (!get(vargs[[i]][1]) %in% vargs[[i]][-1]) {
            message("Invalid `", vargs[[i]][1], "` argument. Defaults to \"", vargs[[i]][[2]], "\".")
            assign(vargs[[i]][1], vargs[[i]][2])
        }
    }
    if (!all(data[, lr.var] %in% c("right", "left"))) stop("`lr.var` cannot have values different from \"left\" and \"right\"")

    # Set up dedicated environment for the humap
        humapr_env <<- new.env(parent = emptyenv())
        sargs <- match.call()[-c(1, 2)] # Supplied arguments
        args <- formals()[-1] # Defaults args
        args[names(args) %in% names(sargs)] <- sargs
        for (arg in names(args)) humapr_env[[arg]] <- args[[arg]]
        if (is.null(humapr_env$anno_gp)) humapr_env$anno_gp <- grid::gpar(col = "black", fontsize = 9)

    # Import appropriate XML file and retain (i.e., rename()) path id's
        geom_file <- paste0("data/", type, "_", region, "_", gender, "_", proj, ".xml")
        humapr_env$surf <- grImport::readPicture(geom_file)
        humapr_env$path_ids <- unlist(XML::xpathApply(XML::xmlInternalTreeParse(geom_file),
                                      "//path[@id]", XML::xmlGetAttr, "id"))
        names(humapr_env$surf@paths) <- humapr_env$path_ids # Give paths original names
        if (half %in% c("right", "left")) {
            humapr_env$path_ids <- grep(paste0(half, "_"), humapr_env$path_ids, value = TRUE)
            humapr_env$surf <- humapr_env$surf[humapr_env$path_ids]
        }

    # Generate mapped_loc variable
        humapr_env$regions <- grep("_outline", humapr_env$path_ids, value = TRUE, invert = TRUE)
        if (half == "mirror") {
            data$loc_long <- as.character(data[, loc.var])
            humapr_env$regions <- substring(grep("right_", humapr_env$regions, value = TRUE), 7)

        } else if (half %in% c("left", "right")) {
            data$loc_long <- ifelse(data[, lr.var] == half,
                                    as.character(paste0(half, "_", data[, loc.var])),
                                    NA)
            humapr_env$regions <- grep(paste0(half, "_"), humapr_env$regions, value = TRUE)
        } else {
            data$loc_long <- as.character(paste0(data[, lr.var], "_", data[, loc.var]))
        }

        if (!is.null(combine)) {
            humapr_env$comb_key <- list()
            for (new_loc in names(combine)) {
                for (old_loc in combine[[new_loc]]) {
                    humapr_env$comb_key[[old_loc]] <- new_loc
                }
            }
            humapr_env$comb_key <- do.call(c, humapr_env$comb_key)

            # This must support half = "both"; so user doesn't have to merge left_chest and left_abdomen, but just chest and abdomen
            data$mapped_loc <- ifelse(data$loc_long %in% names(humapr_env$comb_key),
                                      humapr_env$comb_key[data$loc_long],
                                      data$loc_long)
        } else {
            data$mapped_loc <- data$loc_long
        }
        humapr_env$N <- sum(!is.na(data$mapped_loc))

    # Generate data for annotations
        if (annotate) {
            mids <- list()
            if (half == "mirror") {
                for (id in paste0("right_", humapr_env$regions)) {
                    mids[[id]] <- find_midpoint(humapr_env$surf@paths[[id]])
                }
            } else {
                for (id in humapr_env$regions) {
                    mids[[id]] <- find_midpoint(humapr_env$surf@paths[[id]])
                }
            }
            humapr_env$mids <- do.call(rbind, mids)
        }

    ggplot(data, aes(x = mapped_loc, fill = ..count..)) +
        eval(call(paste0("geom_", region))) +
        guides(fill = FALSE) +
        theme(axis.title = element_blank(),
              axis.text = element_blank(),
              axis.line = element_blank(),
              axis.ticks = element_blank(),
              panel.grid = element_blank(),
              legend.title = element_blank()) +
        scale_fill_gradient(low = "#56B1F7", high = "#132B43")
}
